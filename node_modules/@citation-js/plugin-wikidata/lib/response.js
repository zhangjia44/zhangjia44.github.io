"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fillCache = fillCache;
exports.fillCacheAsync = fillCacheAsync;
exports.parse = parse;
exports.parseAsync = parseAsync;
var _wikidataSdk = require("wikidata-sdk");
var _api = require("./api.js");
var _id = require("./id.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const SIMPLIFY_OPTS = {
  keepQualifiers: true,
  timeConverter: 'simple-day'
};
const FETCH_PLACE = {
  P17: null
};
const FETCH_PUBLISHER = {
  P740: FETCH_PLACE,
  P159: FETCH_PLACE
};
const FETCH_ADDITIONAL = {
  P50: null,
  P57: null,
  P58: null,
  P86: null,
  P98: null,
  P110: null,
  P162: null,
  P170: null,
  P175: null,
  P178: null,
  P371: null,
  P488: null,
  P655: null,
  P664: null,
  P1431: null,
  P1640: null,
  P1817: null,
  P2438: null,
  P5030: null,
  P921: {
    P50: null
  },
  P407: null,
  P364: null,
  P123: FETCH_PUBLISHER,
  P629: {
    P50: null,
    P123: FETCH_PUBLISHER
  },
  P437: null,
  P186: null,
  P179: {
    P98: null
  },
  P1433: {
    P4745: {
      P276: FETCH_PLACE
    }
  },
  P361: {
    P50: null
  }
};
function collectAdditionalIds(entity, needed) {
  if (!needed) {
    return [];
  }
  entity._needed = Object.assign(entity._needed || {}, needed);
  return Object.keys(entity.claims).filter(prop => prop in needed).flatMap(prop => entity.claims[prop].map(({
    value
  }) => value.id || value));
}
function completeResponse(entities, old) {
  if (!old) {
    const allIds = [];
    for (const id in entities) {
      const ids = collectAdditionalIds(entities[id], FETCH_ADDITIONAL);
      for (const id of ids) {
        if (!allIds.includes(id)) {
          allIds.push(id);
        }
      }
    }
    return allIds;
  }
  const ids = [];
  for (const id of old) {
    const entity = entities[id];
    if (!entity._needed) {
      continue;
    }
    for (const prop in entity.claims) {
      if (prop in entity._needed) {
        for (const claim of entity.claims[prop]) {
          if (claim.value && claim.value.id) {
            continue;
          }
          claim.value = entities[claim.value];
          ids.push(...collectAdditionalIds(claim.value, entity._needed[prop]));
        }
      }
    }
    delete entity._needed;
  }
  return ids;
}
function simplifyEntities(entities) {
  const simplified = _wikidataSdk.simplify.entities(entities, SIMPLIFY_OPTS);
  for (const id in entities) {
    const claims = entities[id].claims;
    if (claims.P348) {
      simplified[id].claims['P348:all'] = _wikidataSdk.simplify.propertyClaims(claims.P348, _objectSpread(_objectSpread({}, SIMPLIFY_OPTS), {}, {
        keepNonTruthy: true,
        keepRank: true
      })).filter(claim => claim.rank !== 'deprecated');
    }
  }
  return simplified;
}
function initLoopState(entities, cache) {
  return {
    needed: completeResponse(cache),
    incomplete: Object.keys(entities)
  };
}
function filterIdsAndGetUrls(needed, cache) {
  const shouldFetch = needed.filter((id, i) => !(id in cache) && needed.indexOf(id) === i);
  return (0, _id.parse)(shouldFetch);
}
function addItemsToCache(response, cache) {
  const {
    entities
  } = JSON.parse(response);
  Object.assign(cache, simplifyEntities(entities));
}
function updateLoopState(state, cache) {
  return {
    needed: completeResponse(cache, state.incomplete),
    incomplete: state.needed
  };
}
function finalizeItems(entities, cache) {
  return Object.keys(entities).map(id => cache[id]);
}
function fillCache(entities) {
  const cache = simplifyEntities(entities);
  let state = initLoopState(entities, cache);
  while (state.needed.length) {
    const urls = filterIdsAndGetUrls(state.needed, cache);
    urls.map(url => addItemsToCache((0, _api.parse)(url), cache));
    state = updateLoopState(state, cache);
  }
  return cache;
}
function parse(entities) {
  const cache = fillCache(entities);
  return finalizeItems(entities, cache);
}
async function fillCacheAsync(entities) {
  const cache = simplifyEntities(entities);
  let state = initLoopState(entities, cache);
  while (state.needed.length) {
    const urls = filterIdsAndGetUrls(state.needed, cache);
    await Promise.all(urls.map(async url => addItemsToCache(await (0, _api.parseAsync)(url), cache)));
    state = updateLoopState(state, cache);
  }
  return cache;
}
async function parseAsync(entities) {
  const cache = await fillCacheAsync(entities);
  return finalizeItems(entities, cache);
}